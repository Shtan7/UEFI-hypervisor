#include "math_common.h"

static const int init_jk[] = {2,3,4,6}; /* initial value for jk */

static double PIo2[] = {
  1.57079625129699707031e+00, /* 0x3FF921FB, 0x40000000 */
  7.54978941586159635335e-08, /* 0x3E74442D, 0x00000000 */
  5.39030252995776476554e-15, /* 0x3CF84698, 0x80000000 */
  3.28200341580791294123e-22, /* 0x3B78CC51, 0x60000000 */
  1.27065575308067607349e-29, /* 0x39F01B83, 0x80000000 */
  1.22933308981111328932e-36, /* 0x387A2520, 0x40000000 */
  2.73370053816464559624e-44, /* 0x36E38222, 0x80000000 */
  2.16741683877804819444e-51, /* 0x3569F31D, 0x00000000 */
};

static double			
zero   = 0.0,
one    = 1.0,
two24   =  1.67772160000000000000e+07, /* 0x41700000, 0x00000000 */
twon24  =  5.96046447753906250000e-08; /* 0x3E700000, 0x00000000 */

int __kernel_rem_pio2(double *x, double *y, int e0, int nx, int prec, const int *ipio2) 
{
  int jz,jx,jv,jp,jk,carry,n,iq[20],i,j,k,m,q0,ih;
  double z,fw,f[20],fq[20],q[20];

  /* initialize jk*/
  jk = init_jk[prec];
  jp = jk;

  /* determine jx,jv,q0, note that 3>q0 */
  jx =  nx-1;
  jv = (e0-3)/24; if(jv<0) jv=0;
  q0 =  e0-24*(jv+1);

  /* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
  j = jv-jx; m = jx+jk;
  for(i=0;i<=m;i++,j++) f[i] = (j<0)? zero : (double) ipio2[j];

  /* compute q[0],q[1],...q[jk] */
  for (i=0;i<=jk;i++) {
    for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j]; q[i] = fw;
  }

  jz = jk;
recompute:
  /* distill q[] into iq[] reversingly */
  for(i=0,j=jz,z=q[jz];j>0;i++,j--) {
    fw    =  (double)((int)(twon24* z));
    iq[i] =  (int)(z-two24*fw);
    z     =  q[j-1]+fw;
  }

  /* compute n */
  z  = __ieee754_scalbn(z,q0);		/* actual value of z */
  z -= 8.0*floor(z*0.125);		/* trim off integer >= 8 */
  n  = (int) z;
  z -= (double)n;
  ih = 0;
  if(q0>0) {	/* need iq[jz-1] to determine n */
    i  = (iq[jz-1]>>(24-q0)); n += i;
    iq[jz-1] -= i<<(24-q0);
    ih = iq[jz-1]>>(23-q0);
  } 
  else if(q0==0) ih = iq[jz-1]>>23;
  else if(z>=0.5) ih=2;

  if(ih>0) {	/* q > 0.5 */
    n += 1; carry = 0;
    for(i=0;i<jz ;i++) {	/* compute 1-q */
      j = iq[i];
      if(carry==0) {
        if(j!=0) {
          carry = 1; iq[i] = 0x1000000- j;
        }
      } else  iq[i] = 0xffffff - j;
    }
    if(q0>0) {		/* rare case: chance is 1 in 12 */
      switch(q0) {
        case 1:
          iq[jz-1] &= 0x7fffff; break;
        case 2:
          iq[jz-1] &= 0x3fffff; break;
      }
    }
    if(ih==2) {
      z = one - z;
      if(carry!=0) z -= __ieee754_scalbn(one,q0);
    }
  }

  /* check if recomputation is needed */
  if(z==zero) {
    j = 0;
    for (i=jz-1;i>=jk;i--) j |= iq[i];
    if(j==0) { /* need recomputation */
      for(k=1;iq[jk-k]==0;k++);   /* k = no. of terms needed */

      for(i=jz+1;i<=jz+k;i++) {   /* add q[jz+1] to q[jz+k] */
        f[jx+i] = (double) ipio2[jv+i];
        for(j=0,fw=0.0;j<=jx;j++) fw += x[j]*f[jx+i-j];
        q[i] = fw;
      }
      jz += k;
      goto recompute;
    }
  }

  /* chop off zero terms */
  if(z==0.0) {
    jz -= 1; q0 -= 24;
    while(iq[jz]==0) { jz--; q0-=24;}
  } else { /* break z into 24-bit if necessary */
    z = __ieee754_scalbn(z,-q0);
    if(z>=two24) { 
      fw = (double)((int)(twon24*z));
      iq[jz] = (int)(z-two24*fw);
      jz += 1; q0 += 24;
      iq[jz] = (int) fw;
    } else iq[jz] = (int) z ;
  }

  /* convert integer "bit" chunk to floating-point value */
  fw = __ieee754_scalbn(one,q0);
  for(i=jz;i>=0;i--) {
    q[i] = fw*(double)iq[i]; fw*=twon24;
  }

  /* compute PIo2[0,...,jp]*q[jz,...,0] */
  for(i=jz;i>=0;i--) {
    for(fw=0.0,k=0;k<=jp&&k<=jz-i;k++) fw += PIo2[k]*q[i+k];
    fq[jz-i] = fw;
  }

  /* compress fq[] into y[] */
  switch(prec) {
    case 0:
      fw = 0.0;
      for (i=jz;i>=0;i--) fw += fq[i];
      y[0] = (ih==0)? fw: -fw; 
      break;
    case 1:
    case 2:
      fw = 0.0;
      for (i=jz;i>=0;i--) fw += fq[i]; 
      y[0] = (ih==0)? fw: -fw; 
      fw = fq[0]-fw;
      for (i=1;i<=jz;i++) fw += fq[i];
      y[1] = (ih==0)? fw: -fw; 
      break;
    case 3:	/* painful */
      for (i=jz;i>0;i--) {
        fw      = fq[i-1]+fq[i]; 
        fq[i]  += fq[i-1]-fw;
        fq[i-1] = fw;
      }
      for (i=jz;i>1;i--) {
        fw      = fq[i-1]+fq[i]; 
        fq[i]  += fq[i-1]-fw;
        fq[i-1] = fw;
      }
      for (fw=0.0,i=jz;i>=2;i--) fw += fq[i]; 
      if(ih==0) {
        y[0] =  fq[0]; y[1] =  fq[1]; y[2] =  fw;
      } else {
        y[0] = -fq[0]; y[1] = -fq[1]; y[2] = -fw;
      }
  }
  return n&7;
}
